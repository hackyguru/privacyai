export class TTLSet {
    ttlMs;
    cleanupIntervalId = null;
    entryTimestamps = new Map();
    /**
     * Creates a new CustomSet with TTL functionality.
     * @param ttlMs - The time-to-live in milliseconds for each entry.
     * @param cleanupIntervalMs - Optional interval between cleanup operations (default: 5000ms).
     */
    constructor(ttlMs, cleanupIntervalMs = 5000) {
        this.ttlMs = ttlMs;
        this.startCleanupInterval(cleanupIntervalMs);
    }
    dispose() {
        if (this.cleanupIntervalId !== null) {
            clearInterval(this.cleanupIntervalId);
            this.cleanupIntervalId = null;
        }
        this.entryTimestamps.clear();
    }
    add(entry) {
        this.entryTimestamps.set(entry, Date.now());
        return this;
    }
    has(entry) {
        return this.entryTimestamps.has(entry);
    }
    startCleanupInterval(intervalMs) {
        this.cleanupIntervalId = setInterval(() => {
            this.removeExpiredEntries();
        }, intervalMs);
    }
    removeExpiredEntries() {
        const now = Date.now();
        for (const [entry, timestamp] of this.entryTimestamps.entries()) {
            if (now - timestamp > this.ttlMs) {
                this.entryTimestamps.delete(entry);
            }
        }
    }
}
//# sourceMappingURL=utils.js.map