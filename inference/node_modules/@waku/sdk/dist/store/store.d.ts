import { IDecodedMessage, IDecoder, IStore, Libp2p, QueryRequestParams, StoreCursor, StoreProtocolOptions } from "@waku/interfaces";
import { PeerManager } from "../peer_manager/index.js";
type StoreConstructorParams = {
    libp2p: Libp2p;
    peerManager: PeerManager;
    options?: Partial<StoreProtocolOptions>;
};
/**
 * StoreSDK is an implementation of the IStoreSDK interface.
 * It provides methods to interact with the Waku Store protocol.
 */
export declare class Store implements IStore {
    private readonly options;
    private readonly libp2p;
    private readonly peerManager;
    private readonly protocol;
    constructor(params: StoreConstructorParams);
    get multicodec(): string;
    /**
     * Queries the Waku Store for historical messages using the provided decoders and options.
     * Returns an asynchronous generator that yields promises of decoded messages.
     *
     * @param decoders - An array of message decoders.
     * @param options - Optional query parameters.
     * @returns An asynchronous generator of promises of decoded messages.
     * @throws If no peers are available to query or if an error occurs during the query.
     */
    queryGenerator<T extends IDecodedMessage>(decoders: IDecoder<T>[], options?: Partial<QueryRequestParams>): AsyncGenerator<Promise<T | undefined>[]>;
    /**
     * Queries the Waku Store for historical messages and processes them with the provided callback in order.
     *
     * @param decoders - An array of message decoders.
     * @param callback - A callback function to process each decoded message.
     * @param options - Optional query parameters.
     * @returns A promise that resolves when the query and message processing are completed.
     */
    queryWithOrderedCallback<T extends IDecodedMessage>(decoders: IDecoder<T>[], callback: (message: T) => Promise<void | boolean> | boolean | void, options?: Partial<QueryRequestParams>): Promise<void>;
    /**
     * Queries the Waku Store for historical messages and processes them with the provided callback using promises.
     *
     * @param decoders - An array of message decoders.
     * @param callback - A callback function to process each promise of a decoded message.
     * @param options - Optional query parameters.
     * @returns A promise that resolves when the query and message processing are completed.
     */
    queryWithPromiseCallback<T extends IDecodedMessage>(decoders: IDecoder<T>[], callback: (message: Promise<T | undefined>) => Promise<void | boolean> | boolean | void, options?: Partial<QueryRequestParams>): Promise<void>;
    /**
     * Processes messages based on the provided callback and options.
     *
     * @param messages - An array of promises of decoded messages.
     * @param callback - A callback function to process each decoded message.
     * @returns A promise that resolves to a boolean indicating whether the processing should abort.
     * @private
     */
    private processMessages;
    /**
     * Creates a cursor based on the provided decoded message.
     *
     * @param message - The decoded message.
     * @returns A StoreCursor representing the message.
     */
    createCursor(message: IDecodedMessage): StoreCursor;
    /**
     * Validates the provided decoders and pubsub topic.
     *
     * @param decoders - An array of message decoders.
     * @returns An object containing the pubsub topic, content topics, and a map of decoders.
     * @throws If no decoders are provided, if multiple pubsub topics are provided, or if no decoders are found for the pubsub topic.
     * @private
     */
    private validateDecodersAndPubsubTopic;
    private getPeerToUse;
    private getPeerFromConfigurationOrFirst;
    private buildQueryParams;
}
export {};
