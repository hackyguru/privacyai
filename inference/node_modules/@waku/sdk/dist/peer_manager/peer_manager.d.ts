import { PeerId, TypedEventEmitter } from "@libp2p/interface";
import { ConnectionManager } from "@waku/core";
import { Libp2p, Protocols } from "@waku/interfaces";
type PeerManagerConfig = {
    numPeersToUse?: number;
};
type PeerManagerParams = {
    libp2p: Libp2p;
    config?: PeerManagerConfig;
    connectionManager: ConnectionManager;
};
type GetPeersParams = {
    protocol: Protocols;
    pubsubTopic: string;
};
export declare enum PeerManagerEventNames {
    Connect = "filter:connect",
    Disconnect = "filter:disconnect"
}
interface IPeerManagerEvents {
    /**
     * Notifies about Filter peer being connected.
     */
    [PeerManagerEventNames.Connect]: CustomEvent<PeerId>;
    /**
     * Notifies about Filter peer being disconnected.
     */
    [PeerManagerEventNames.Disconnect]: CustomEvent<PeerId>;
}
/**
 * @description
 * PeerManager is responsible for:
 * - finding available peers based on shard / protocols;
 * - notifying when peers for a specific protocol are connected;
 * - notifying when peers for a specific protocol are disconnected;
 */
export declare class PeerManager {
    readonly events: TypedEventEmitter<IPeerManagerEvents>;
    private readonly numPeersToUse;
    private readonly libp2p;
    private readonly connectionManager;
    private readonly lockedPeers;
    private readonly unlockedPeers;
    constructor(params: PeerManagerParams);
    start(): void;
    stop(): void;
    getPeers(params: GetPeersParams): Promise<PeerId[]>;
    renewPeer(id: PeerId, params: GetPeersParams): Promise<void>;
    isPeerOnPubsub(id: PeerId, pubsubTopic: string): Promise<boolean>;
    private onConnected;
    private onDisconnected;
    private hasPeerProtocol;
    private lockPeer;
    private isPeerLocked;
    private unlockPeer;
    private isPeerAvailableForUse;
    private dispatchFilterPeerConnect;
    private dispatchFilterPeerDisconnect;
    private matchProtocolToCodec;
}
export {};
